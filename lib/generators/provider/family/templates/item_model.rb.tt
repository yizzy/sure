class <%= class_name %>Item < ApplicationRecord
  include Syncable, Provided, Unlinking

  enum :status, { good: "good", requires_update: "requires_update" }, default: :good

  # Helper to detect if ActiveRecord Encryption is configured for this app
  def self.encryption_ready?
    creds_ready = Rails.application.credentials.active_record_encryption.present?
    env_ready = ENV["ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY"].present? &&
                ENV["ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY"].present? &&
                ENV["ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT"].present?
    creds_ready || env_ready
  end

  # Encrypt sensitive credentials if ActiveRecord encryption is configured
  if encryption_ready?
<% parsed_fields.select { |f| f[:secret] }.each do |field| -%>
    encrypts :<%= field[:name] %>, deterministic: true
<% end -%>
  end

  validates :name, presence: true
<% parsed_fields.select { |f| f[:secret] }.each do |field| -%>
  validates :<%= field[:name] %>, presence: true, on: :create
<% end -%>

  belongs_to :family
  has_one_attached :logo

  has_many :<%= file_name %>_accounts, dependent: :destroy
  has_many :accounts, through: :<%= file_name %>_accounts

  scope :active, -> { where(scheduled_for_deletion: false) }
  scope :ordered, -> { order(created_at: :desc) }
  scope :needs_update, -> { where(status: :requires_update) }

  def destroy_later
    update!(scheduled_for_deletion: true)
    DestroyJob.perform_later(self)
  end

  # TODO: Implement data import from provider API
  # This method should fetch the latest data from the provider and import it.
  # May need provider-specific validation (e.g., session validity checks).
  # See LunchflowItem#import_latest_lunchflow_data or EnableBankingItem#import_latest_enable_banking_data for examples.
  def import_latest_<%= file_name %>_data
    provider = <%= file_name %>_provider
    unless provider
      Rails.logger.error "<%= class_name %>Item #{id} - Cannot import: provider is not configured"
      raise StandardError.new("<%= class_name %> provider is not configured")
    end

    # TODO: Add any provider-specific validation here (e.g., session checks)
    <%= class_name %>Item::Importer.new(self, <%= file_name %>_provider: provider).import
  rescue => e
    Rails.logger.error "<%= class_name %>Item #{id} - Failed to import data: #{e.message}"
    raise
  end

  # TODO: Implement account processing logic
  # This method processes linked accounts after data import.
  # Customize based on your provider's data structure and processing needs.
  def process_accounts
    return [] if <%= file_name %>_accounts.empty?

    results = []
    <%= file_name %>_accounts.joins(:account).merge(Account.visible).each do |<%= file_name %>_account|
      begin
        result = <%= class_name %>Account::Processor.new(<%= file_name %>_account).process
        results << { <%= file_name %>_account_id: <%= file_name %>_account.id, success: true, result: result }
      rescue => e
        Rails.logger.error "<%= class_name %>Item #{id} - Failed to process account #{<%= file_name %>_account.id}: #{e.message}"
        results << { <%= file_name %>_account_id: <%= file_name %>_account.id, success: false, error: e.message }
      end
    end

    results
  end

  # TODO: Customize sync scheduling if needed
  # This method schedules sync jobs for all linked accounts.
  def schedule_account_syncs(parent_sync: nil, window_start_date: nil, window_end_date: nil)
    return [] if accounts.empty?

    results = []
    accounts.visible.each do |account|
      begin
        account.sync_later(
          parent_sync: parent_sync,
          window_start_date: window_start_date,
          window_end_date: window_end_date
        )
        results << { account_id: account.id, success: true }
      rescue => e
        Rails.logger.error "<%= class_name %>Item #{id} - Failed to schedule sync for account #{account.id}: #{e.message}"
        results << { account_id: account.id, success: false, error: e.message }
      end
    end

    results
  end

  def upsert_<%= file_name %>_snapshot!(accounts_snapshot)
    assign_attributes(
      raw_payload: accounts_snapshot
    )

    save!
  end

  def has_completed_initial_setup?
    # Setup is complete if we have any linked accounts
    accounts.any?
  end

  # TODO: Customize sync status summary if needed
  # Some providers use latest_sync.sync_stats, others use count methods directly.
  # See SimplefinItem#sync_status_summary or EnableBankingItem#sync_status_summary for examples.
  def sync_status_summary
    total_accounts = total_accounts_count
    linked_count = linked_accounts_count
    unlinked_count = unlinked_accounts_count

    if total_accounts == 0
      "No accounts found"
    elsif unlinked_count == 0
      "#{linked_count} #{'account'.pluralize(linked_count)} synced"
    else
      "#{linked_count} synced, #{unlinked_count} need setup"
    end
  end

  def linked_accounts_count
    <%= file_name %>_accounts.joins(:account_provider).count
  end

  def unlinked_accounts_count
    <%= file_name %>_accounts.left_joins(:account_provider).where(account_providers: { id: nil }).count
  end

  def total_accounts_count
    <%= file_name %>_accounts.count
  end

  def institution_display_name
    institution_name.presence || institution_domain.presence || name
  end

  # TODO: Customize based on how your provider stores institution data
  # SimpleFin uses org_data, others use institution_metadata.
  # Adjust the field name and key lookups as needed.
  def connected_institutions
    <%= file_name %>_accounts.includes(:account)
                  .where.not(institution_metadata: nil)
                  .map { |acc| acc.institution_metadata }
                  .uniq { |inst| inst["name"] || inst["institution_name"] }
  end

  # TODO: Customize institution summary if your provider has special fields
  # EnableBanking uses aspsp_name as a fallback, for example.
  def institution_summary
    institutions = connected_institutions
    case institutions.count
    when 0
      "No institutions connected"
    when 1
      institutions.first["name"] || institutions.first["institution_name"] || "1 institution"
    else
      "#{institutions.count} institutions"
    end
  end

  def credentials_configured?
<% if parsed_fields.select { |f| f[:secret] }.any? -%>
    <%= parsed_fields.select { |f| f[:secret] }.map { |f| "#{f[:name]}.present?" }.join(" && ") %>
<% else -%>
    true
<% end -%>
  end

<% parsed_fields.select { |f| f[:default] }.each do |field| -%>
  def effective_<%= field[:name] %>
    <%= field[:name] %>.presence || "<%= field[:default] %>"
  end

<% end -%>
end
